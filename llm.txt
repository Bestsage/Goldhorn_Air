# Goldhorn_Air - LLM Reference (Documentation Complète)

Version de ce document: 2026-02-22
Statut firmware: DShot TAB verrouillé en sécurité (sortie forcée à 0)

---

## 1) Résumé exécutif

Ce dépôt contient un firmware Rust embarqué (no_std) pour STM32F405RG.
Il gère:
- Acquisition capteurs: IMU, baromètre, magnétomètre
- Estimation d'attitude (AHRS Mahony)
- Estimation altitude/vitesse verticale (Kalman vertical)
- Télémetrie USB + CRSF
- Commande moteur TAB via DShot300 sur un port moteur Betaflight

Point critique actuel:
- Le moteur TAB est désactivé par sécurité logicielle.
- `ESC_OUTPUT_LOCKED = true` dans `src/main.rs` force la commande DShot à 0.

---

## 2) Arborescence utile

- `src/main.rs` : orchestration complète, init hardware, boucle de vol, télémétrie, logique de commande TAB
- `src/board.rs` : configuration clocks RCC (HSE 8 MHz -> SYSCLK 168 MHz)
- `src/usb.rs` : initialisation USB CDC
- `src/drivers/mod.rs` : exports des modules
- `src/drivers/icm42688.rs` : IMU SPI
- `src/drivers/spl06.rs` : baromètre I2C
- `src/drivers/hmc5883.rs` : magnétomètre I2C
- `src/drivers/ahrs.rs` : AHRS Mahony + quaternion + Euler
- `src/drivers/kalman.rs` : Kalman vertical (position + vitesse)
- `src/drivers/filter.rs` : filtres LPF/PT1/Biquad
- `src/drivers/gps.rs` : parser NMEA
- `src/drivers/crsf.rs` : parser RC CRSF + encode télémetrie CRSF
- `src/drivers/roll.rs` : contrôleurs roll/tab + mappings CRSF/DShot
- `src/drivers/dshot.rs` : driver DShot300 bit-bang
- `.cargo/config.toml` : target embarquée et runner
- `flash_monitor.sh` : build binaire + flash DFU + moniteur série
- `BTFL_cli_20260126_153309_JHEF405PRO.txt` : dump Betaflight (mapping ressources)

---

## 3) Environnement build et toolchain

### 3.1 Target Rust
- Target compilée: `thumbv7em-none-eabihf`
- Déclarée dans `.cargo/config.toml`

### 3.2 Outils nécessaires
- Rust + Cargo
- Rustup (fortement recommandé)
- target `thumbv7em-none-eabihf`
- `cargo-binutils` + `llvm-tools-preview` (pour `cargo objcopy`)
- `dfu-util` (flash DFU)

### 3.3 Cas Arch Linux
Si `rustup` absent mais `rustc/cargo` système présents:
1. `sudo pacman -S --needed rustup`
2. `rustup default stable`
3. `rustup target add thumbv7em-none-eabihf`
4. `cargo install cargo-binutils`
5. `rustup component add llvm-tools-preview`

Le script `flash_monitor.sh` détecte désormais ce scénario et affiche des instructions explicites.

---

## 4) Horloges et plateforme MCU

Défini dans `src/board.rs`:
- HSE = 8 MHz
- PLL: prediv /4, mul x168, divP /2
- SYSCLK = 168 MHz
- AHB prescaler = DIV1
- APB1 = DIV4
- APB2 = DIV2
- USB via PLLQ /7 (48 MHz)

---

## 5) Mapping hardware réel (code + Betaflight)

### 5.1 Bus et capteurs
- I2C1: PB8 (SCL), PB9 (SDA)
  - SPL06 (baro)
  - HMC5883 (mag)
- SPI1: PA5 SCK / PA7 MOSI / PA6 MISO / PB12 CS
  - ICM42688
- SPI3: PC10 SCK / PC12 MOSI / PC11 MISO / PB3 CS
  - Flash W25Qxx

### 5.2 UART
- GPS: USART3, RX PB11 / TX PB10, 9600 bauds
- CRSF/ELRS: UART4, RX PA1 / TX PA0, 420000 bauds

### 5.3 ADC et GPIO
- VBat: PC3 (ADC1_IN13), ratio de conversion utilisé: x11.0
- LED heartbeat: PC13

### 5.4 Port moteur TAB choisi
Depuis le dump Betaflight:
- `resource MOTOR 1 B00`
- Timer associé: TIM3 CH3 (AF2)

Le firmware utilise ce port:
- DShot TAB: PB0 (`src/main.rs` + `src/drivers/dshot.rs`)

### 5.5 Partie Ground Hardware (détaillée)

Cette section décrit **le hardware côté sol / banc** requis pour exploiter le dépôt, avec distinction claire entre:
- **Architecture A (active dans `src/main.rs`)**: STM32 -> ESC BLHeli/Bluejay en DShot300 sur PB0
- **Architecture B (alternative dans `esp32_c3_tab_controller/`)**: STM32 (ou autre main board) -> ESP32-C3 -> driver STEP/DIR -> NEMA17

#### 5.5.1 Composants (BOM) — Architecture A (DShot direct)

Indispensables:
- 1x FC STM32F405RG (JHEF405 Pro d'après le projet)
- 1x ESC compatible DShot (Bluejay/BLHeli32), configuré pour usage 3D si commande signée
- 1x moteur du TAB (BLDC)
- 1x récepteur ELRS/CRSF (UART4)
- 1x source alim principale (LiPo) + régulation FC
- 1x USB vers PC (télémétrie CDC)

Capteurs exploités par le code:
- ICM42688 (IMU) sur SPI1
- SPL06 (baro) sur I2C1
- HMC5883 (mag) sur I2C1
- GPS NMEA sur USART3

#### 5.5.2 Branchement précis — Architecture A (DShot direct)

Main board STM32F405:
- TAB DShot: PB0 -> signal ESC (port Betaflight MOTOR1, `resource MOTOR 1 B00`)
- GND FC -> GND ESC (référence commune impérative)
- VBat: PC3 (ADC1_IN13) via diviseur (ratio code x11.0)
- USB: PA12/PA11 (USB FS)
- ELRS/CRSF: UART4 RX PA1 / TX PA0
- GPS: USART3 RX PB11 / TX PB10
- I2C capteurs: PB8/PB9
- IMU SPI1: PA5/PA6/PA7 + CS PB12
- Flash SPI3: PC10/PC11/PC12 + CS PB3

Règles de câblage critiques:
- Masse commune entre tous les blocs logiques (FC, ESC, RX, GPS, capteurs)
- Ligne DShot PB0 courte/propre, éviter passage parallèle puissance
- Alimentation ESC/moteur séparée des rails capteurs si possible
- Vérifier polarité et continuité avant mise sous tension

#### 5.5.3 Composants (BOM) — Architecture B (ESP32-C3 Stepper)

Dans `esp32_c3_tab_controller/`:
- 1x ESP32-C3 Super Mini
- 1x driver STEP/DIR/EN (A4988, DRV8825, TMC en mode STEP-DIR)
- 1x NEMA17
- 1x alimentation moteur dédiée (selon couple/vitesse)
- 1x liaison UART entre main board et ESP32-C3

#### 5.5.4 Branchement précis — Architecture B (ESP32-C3 Stepper)

ESP32-C3 vers driver:
- GPIO4 -> STEP
- GPIO5 -> DIR
- GPIO6 -> EN (actif LOW)

UART contrôle:
- ESP32 GPIO21 (TX) -> RX main board
- ESP32 GPIO20 (RX) <- TX main board
- GND ESP32 <-> GND main board (obligatoire)

Notes alim:
- Driver/NEMA17 alimentés séparément de l'ESP32
- ESP32 alimenté proprement (USB 5V ou régulateur dédié)

#### 5.5.5 Comment fonctionne le code — Architecture A (`src/main.rs`)

Chaîne fonctionnelle (réel firmware principal):
1. Init clocks/USB/bus (I2C, SPI1, SPI3, UART3, UART4, ADC)
2. Init capteurs + calibration (baro sol, biais IMU)
3. Boucle ~20 Hz:
  - lecture IMU + filtres
  - update AHRS 9DOF
  - calcul accel verticale + Kalman vertical
  - lecture CRSF (RC) + GPS
  - calcul consigne TAB depuis contrôle roll
4. Conversion TAB -> commande ESC:
  - `signed_unit_to_dshot_3d()` pour transformer commande signée [-1..1] en DShot 3D
  - stockage dans `TAB_MOTOR_DSHOT_CMD`
5. Task dédiée `dshot_tab_task` à 1 kHz:
  - envoie continu DShot300 sur PB0
  - si `ESC_OUTPUT_LOCKED == true`, force command `0`

Sécurité effective actuelle:
- `ESC_OUTPUT_LOCKED` est à `true` dans le code actuel
- même avec RC armé, le moteur TAB reste à 0 tant que ce verrou n'est pas retiré

#### 5.5.6 Comment fonctionne le code — Architecture B (`esp32_c3_tab_controller.ino`)

Chaîne fonctionnelle (firmware auxiliaire):
1. Boot ESP32: sorties configurées, driver désactivé par défaut (`EN` inactif)
2. UART 115200: parser commandes ASCII
  - `EN 1|0`, `SET <deg>`, `HOME`, `PING`
3. Boucle contrôle:
  - clamp angle TAB à ±20°
  - conversion degrés TAB -> steps moteur via `GEAR_RATIO`, `MICROSTEP`, `FULL_STEPS_PER_REV`
  - rampe accel/vitesse (`MAX_ACCEL_STEPS_S2`, `MAX_SPEED_STEPS_S`)
  - génération impulsions STEP et direction DIR
4. Failsafe liaison:
  - timeout `CMD_TIMEOUT_MS=300` ms sans commande valide -> `EN 0`
5. Statut:
  - publication `STAT ...` toutes les 100 ms

Important:
- Cette architecture B est fournie dans le dépôt mais **n'est pas pilotée par `src/main.rs` actuellement**
- c'est une base alternative pour remplacement de l'ESC BLDC par actionneur pas-à-pas

---

## 6) Runtime, tâches et fréquence

### 6.1 Tâches Embassy
- `main` : boucle principale capteurs/fusion/contrôle/télémétrie
- `usb_task` : service USB CDC
- `dshot_tab_task` : envoi DShot à période fixe

### 6.2 Fréquences principales
- Boucle principale: ~20 Hz (`Timer::after(50 ms)`)
- Task DShot: 1 kHz (`Timer::after(1000 us)`)

Note: l'envoi DShot à 20 Hz était insuffisant pour un ESC. Le passage à 1 kHz corrige ce point architectural.

---

## 7) Chaîne de traitement capteurs

## 7.1 Calibration initiale
- Baro: moyenne de 10 échantillons pour altitude sol (`ground_alt`)
- IMU: 100 échantillons pour biais accel/gyro
- Correction accel Z ajustée pour 1g nominal

## 7.2 Filtrage
- Gyro: PT1 10 Hz
- Accel: Biquad LPF 5 Hz, Q=0.707
- Accel verticale linéaire: LPF alpha=0.5
- Altitude baro: LPF alpha=0.2

## 7.3 Fusion attitude
- Mahony 9DOF (`update_9dof`) avec gyro+accel+mag
- Conversion quaternion -> Euler utilisée pour roll/pitch/yaw

## 7.4 Estimation verticale
- Kalman vertical 2 états
  - état: position, vitesse
  - prédiction par accel verticale (earth frame - gravité)
  - correction par altitude baro filtrée

---

## 8) Contrôle roll -> tab

Implémenté dans `src/drivers/roll.rs` et utilisé dans `src/main.rs`.

### 8.1 Entrées RC
- Roll stick: CH0 (normalisé [-1, +1])
- Throttle: CH2
- Arm: CH4 (`> 1200`)
- Sélecteur ratio: CH5
  - <=1500 => 10:1
  - >1500 => 20:1

### 8.2 Contrôleur roll (boucle attitude)
- Type: PID simple sur erreur d'angle
- Sortie bornée [-1, +1] (`output_limit`)
- Damping via taux gyro roll

### 8.3 Conversion en cible tab
- `tab_target_deg = roll_output * 20°`
- Saturation stricte à ±20°

### 8.4 Contrôleur tab engrené
- Modèle simple position moteur (open-loop)
- Convertit angle tab cible en angle moteur cible avec ratio 10:1 ou 20:1
- Génère commande moteur signée dans [-1, +1]
- Estime position moteur/tab sans retour capteur

Limitation importante:
- Sans retour position (encodeur/potentiomètre), la précision absolue est limitée sous charge.

---

## 9) DShot300

### 9.1 Driver
`src/drivers/dshot.rs`:
- Génère trame 16 bits (11-bit command + telemetry bit + checksum nibble)
- Bit-bang timing via `cortex_m::asm::delay`
- `send_command(command_11bit, telemetry)`

### 9.2 Commandes
- Mapping unidirectionnel: `unit_to_dshot`
- Mapping 3D signé: `signed_unit_to_dshot_3d`
  - positif: zone [1048..2047]
  - négatif: zone [1047..48]

### 9.3 Sécurité actuelle (très important)
Dans `src/main.rs`:
- `const ESC_OUTPUT_LOCKED: bool = true;`
- Dans `dshot_tab_task`, commande forcée à 0
- Dans la boucle main, commande TAB aussi forcée à 0 avant publication

Conséquence:
- Le moteur TAB ne tournera pas tant que ce verrou n'est pas explicitement retiré.

---

## 10) Télémétrie

### 10.1 USB texte
Paquets texte incluant notamment:
- Température, pression, altitude, vitesse verticale
- GPS lat/lon, sats
- Tension batterie
- Roll mesuré
- Commandes DShot et état TAB

Champs ajoutés côté TAB:
- `B` : angle tab estimé (deg)
- `D` : angle tab cible (deg)
- `g` : gear ratio actif (10/20)
- `M` : commande DShot tab
- `Q` : direction signée tab (0/1)

### 10.2 CRSF retour radio
Frames périodiques:
- Battery
- GPS
- Attitude
- Vario
- Barometer
- Flight mode texte

---

## 11) Build / flash / runbook

### 11.1 Build check rapide
- `cargo check --target thumbv7em-none-eabihf`

### 11.2 Script complet
- `./flash_monitor.sh`
  - Build via `cargo objcopy --release`
  - Flash DFU: `dfu-util -a 0 -s 0x08000000:leave -D firmware.bin`
  - Ouvre ensuite un moniteur série

### 11.3 Prévol software minimal
1. Confirmer `ESC_OUTPUT_LOCKED = true` pour tests capteurs
2. Vérifier USB télémétrie reçue
3. Vérifier channels CRSF (CH0/2/4/5)
4. Vérifier angle roll cohérent quand on incline
5. Vérifier que `M` reste 0 sous verrou

---

## 12) Sécurité matérielle (obligatoire)

- Toujours tester sans hélice
- Limiter courant alimentation (bench PSU si possible)
- Ajouter fusible ou ampoule série lors premiers essais puissance
- Vérifier sens moteur et ratio mécanique à la main avant autorisation couple
- Ne jamais activer déverrouillage ESC sans kill-switch robuste

Après incident de type "magic smoke":
1. Débrancher immédiat LiPo
2. Contrôler ESC, phases moteur, soudures, court-circuits
3. Mesurer résistance phase-phase et phase-masse
4. Repartir avec sortie ESC verrouillée

---

## 13) État sécurité actuel et prochaines étapes recommandées

État actuel:
- Sortie TAB motor logicielle verrouillée à 0
- Build OK
- Flash possible si toolchain installée correctement

Avant réactivation moteur, implémenter au minimum:
1. Armement 2 étapes (switch + throttle bas + délai)
2. Deadband autour du neutre 3D
3. Rampe de consigne (slew-rate limiter)
4. Timeout RX (failsafe -> DShot 0)
5. Journalisation événementielle arm/disarm/failsafe

---

## 14) Erreurs fréquentes et diagnostics

### 14.1 `can't find crate for core`
Cause: target ARM non installée.
Fix:
- `rustup target add thumbv7em-none-eabihf`

### 14.2 `rustup: command not found`
Cause: Rust système sans rustup.
Fix Arch:
- `sudo pacman -S --needed rustup`
- `rustup default stable`

### 14.3 Build ok mais moteur ne tourne pas
Checklist:
- Verrou logiciel actif ? (`ESC_OUTPUT_LOCKED`)
- ESC en mode 3D/bidirectionnel configuré ?
- Arm condition réelle validée (CH4)
- DShot envoyé à fréquence suffisante (task 1 kHz)
- Câblage sur PB0 correct

---

## 15) Contrat de vérité de ce document

Ce document décrit l'état actuel du code du dépôt au moment de génération.
Les sections les plus sensibles à vérifier après modifications futures:
- `src/main.rs` (safety lock, task rates, pin mapping)
- `src/drivers/roll.rs` (mappings commande)
- `src/drivers/dshot.rs` (timings bit-bang)
- `flash_monitor.sh` (toolchain/flash)

Fin du document.
