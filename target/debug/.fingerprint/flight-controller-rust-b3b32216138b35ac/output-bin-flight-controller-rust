{"$message_type":"diagnostic","message":"struct `Board` is never constructed","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/board.rs","byte_start":111,"byte_end":116,"line_start":5,"line_end":5,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub struct Board {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: struct `Board` is never constructed\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/board.rs:5:12\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Board {\n  \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"associated function `init` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/board.rs","byte_start":161,"byte_end":171,"line_start":9,"line_end":9,"column_start":1,"column_end":11,"is_primary":false,"text":[{"text":"impl Board {","highlight_start":1,"highlight_end":11}],"label":"associated function in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/board.rs","byte_start":185,"byte_end":189,"line_start":10,"line_end":10,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn init() -> Self {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: associated function `init` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/board.rs:10:12\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl Board {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94massociated function in this implementation\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn init() -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias `UsbDriver` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":395,"byte_end":404,"line_start":13,"line_end":13,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"pub type UsbDriver = Driver<'static, peripherals::USB_OTG_FS>;","highlight_start":10,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: type alias `UsbDriver` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:13:10\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub type UsbDriver = Driver<'static, peripherals::USB_OTG_FS>;\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type alias `UsbSerial` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":458,"byte_end":467,"line_start":14,"line_end":14,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"pub type UsbSerial<'a> = CdcAcmClass<'a, UsbDriver>;","highlight_start":10,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: type alias `UsbSerial` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:14:10\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub type UsbSerial<'a> = CdcAcmClass<'a, UsbDriver>;\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"struct `UsbResources` is never constructed","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":950,"byte_end":962,"line_start":22,"line_end":22,"column_start":12,"column_end":24,"is_primary":true,"text":[{"text":"pub struct UsbResources<'a> {","highlight_start":12,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: struct `UsbResources` is never constructed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:22:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct UsbResources<'a> {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated function `new` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":1146,"byte_end":1171,"line_start":31,"line_end":31,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"impl<'a> UsbResources<'a> {","highlight_start":1,"highlight_end":26}],"label":"associated function in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/usb.rs","byte_start":1191,"byte_end":1194,"line_start":32,"line_end":32,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"    pub const fn new() -> Self {","highlight_start":18,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: associated function `new` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:32:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<'a> UsbResources<'a> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94massociated function in this implementation\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const fn new() -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"static `USB_RES` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":1457,"byte_end":1464,"line_start":44,"line_end":44,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"static mut USB_RES: UsbResources<'static> = UsbResources::new();","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: static `USB_RES` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:44:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m static mut USB_RES: UsbResources<'static> = UsbResources::new();\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function `init` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":1643,"byte_end":1647,"line_start":51,"line_end":51,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"pub fn init(","highlight_start":8,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: function `init` is never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:51:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn init(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"struct `Icm42688` is never constructed","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/drivers/icm42688.rs","byte_start":154,"byte_end":162,"line_start":5,"line_end":5,"column_start":12,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Icm42688<'d, T: Instance, Tx: TxDma<T>, Rx: RxDma<T>> {","highlight_start":12,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: struct `Icm42688` is never constructed\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/drivers/icm42688.rs:5:12\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Icm42688<'d, T: Instance, Tx: TxDma<T>, Rx: RxDma<T>> {\n  \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"associated items `new`, `write_reg`, `read_reg`, `init`, `read_who_am_i`, and `read_all` are never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"src/drivers/icm42688.rs","byte_start":270,"byte_end":343,"line_start":10,"line_end":10,"column_start":1,"column_end":74,"is_primary":false,"text":[{"text":"impl<'d, T: Instance, Tx: TxDma<T>, Rx: RxDma<T>> Icm42688<'d, T, Tx, Rx> {","highlight_start":1,"highlight_end":74}],"label":"associated items in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":357,"byte_end":360,"line_start":11,"line_end":11,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(spi: Spi<'d, T, Tx, Rx>, cs: Output<'d, AnyPin>) -> Self {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":465,"byte_end":474,"line_start":15,"line_end":15,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    async fn write_reg(&mut self, reg: u8, value: u8) -> Result<(), Error> {","highlight_start":14,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":701,"byte_end":709,"line_start":23,"line_end":23,"column_start":14,"column_end":22,"is_primary":true,"text":[{"text":"    async fn read_reg(&mut self, reg: u8) -> Result<u8, Error> {","highlight_start":14,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":1002,"byte_end":1006,"line_start":34,"line_end":34,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"    pub async fn init(&mut self) -> Result<(), Error> {","highlight_start":18,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":1567,"byte_end":1580,"line_start":52,"line_end":52,"column_start":18,"column_end":31,"is_primary":true,"text":[{"text":"    pub async fn read_who_am_i(&mut self) -> Result<u8, Error> {","highlight_start":18,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/drivers/icm42688.rs","byte_start":1697,"byte_end":1705,"line_start":57,"line_end":57,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"    pub async fn read_all(&mut self) -> Result<([i16; 3], [i16; 3]), Error> {","highlight_start":18,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: associated items `new`, `write_reg`, `read_reg`, `init`, `read_who_am_i`, and `read_all` are never used\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/drivers/icm42688.rs:11:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl<'d, T: Instance, Tx: TxDma<T>, Rx: RxDma<T>> Icm42688<'d, T, Tx, Rx> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------------------------------------------------------\u001b[0m \u001b[1m\u001b[94massociated items in this implementation\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(spi: Spi<'d, T, Tx, Rx>, cs: Output<'d, AnyPin>) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     async fn write_reg(&mut self, reg: u8, value: u8) -> Result<(), Error> {\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     async fn read_reg(&mut self, reg: u8) -> Result<u8, Error> {\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn init(&mut self) -> Result<(), Error> {\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn read_who_am_i(&mut self) -> Result<u8, Error> {\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn read_all(&mut self) -> Result<([i16; 3], [i16; 3]), Error> {\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"creating a mutable reference to mutable static","code":{"code":"static_mut_refs","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":1956,"byte_end":1982,"line_start":59,"line_end":59,"column_start":31,"column_end":57,"is_primary":true,"text":[{"text":"    let driver_buf = unsafe { &mut USB_RES.ep_out_buffer };","highlight_start":31,"highlight_end":57}],"label":"mutable reference to mutable static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `&raw mut` instead to create a raw pointer","code":null,"level":"help","spans":[{"file_name":"src/usb.rs","byte_start":1956,"byte_end":1961,"line_start":59,"line_end":59,"column_start":31,"column_end":36,"is_primary":true,"text":[{"text":"    let driver_buf = unsafe { &mut USB_RES.ep_out_buffer };","highlight_start":31,"highlight_end":36}],"label":null,"suggested_replacement":"&raw mut ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: creating a mutable reference to mutable static\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:59:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let driver_buf = unsafe { &mut USB_RES.ep_out_buffer };\n   \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mmutable reference to mutable static\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `&raw mut` instead to create a raw pointer\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let driver_buf = unsafe { &\u001b[92mraw \u001b[0mmut USB_RES.ep_out_buffer };\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[92m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"creating a mutable reference to mutable static","code":{"code":"static_mut_refs","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":2377,"byte_end":2389,"line_start":70,"line_end":70,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"        let res = &mut USB_RES;","highlight_start":19,"highlight_end":31}],"label":"mutable reference to mutable static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `&raw mut` instead to create a raw pointer","code":null,"level":"help","spans":[{"file_name":"src/usb.rs","byte_start":2377,"byte_end":2382,"line_start":70,"line_end":70,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"        let res = &mut USB_RES;","highlight_start":19,"highlight_end":24}],"label":null,"suggested_replacement":"&raw mut ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: creating a mutable reference to mutable static\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:70:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let res = &mut USB_RES;\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mmutable reference to mutable static\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives\n\u001b[1m\u001b[96mhelp\u001b[0m: use `&raw mut` instead to create a raw pointer\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let res = &\u001b[92mraw \u001b[0mmut USB_RES;\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"creating a mutable reference to mutable static","code":{"code":"static_mut_refs","explanation":null},"level":"warning","spans":[{"file_name":"src/usb.rs","byte_start":2632,"byte_end":2644,"line_start":81,"line_end":81,"column_start":24,"column_end":36,"is_primary":true,"text":[{"text":"    let res = unsafe { &mut USB_RES };","highlight_start":24,"highlight_end":36}],"label":"mutable reference to mutable static","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `&raw mut` instead to create a raw pointer","code":null,"level":"help","spans":[{"file_name":"src/usb.rs","byte_start":2632,"byte_end":2637,"line_start":81,"line_end":81,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    let res = unsafe { &mut USB_RES };","highlight_start":24,"highlight_end":29}],"label":null,"suggested_replacement":"&raw mut ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: creating a mutable reference to mutable static\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/usb.rs:81:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let res = unsafe { &mut USB_RES };\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mmutable reference to mutable static\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives\n\u001b[1m\u001b[96mhelp\u001b[0m: use `&raw mut` instead to create a raw pointer\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let res = unsafe { &\u001b[92mraw \u001b[0mmut USB_RES };\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[92m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"13 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: 13 warnings emitted\u001b[0m\n\n"}
